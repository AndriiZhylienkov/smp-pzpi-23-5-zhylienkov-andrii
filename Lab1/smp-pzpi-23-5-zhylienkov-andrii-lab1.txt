МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
  
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ
 


 
Дисципліна «Скриптові мови програмування»
Звіт
з лабораторної роботи №1


 
 
   
Виконав:
ст. гр. ПЗПІ-23-5
Жилєнков А. О.


	 
	Перевірив:
ст. викладач кафедри ПІ
Сокорчук І. П.
 
	





Харків – 2025
1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	27.05.2025
	0.1
	Створено розділ «Завдання»
	2
	27.05.2025
	0.1
	Створено розділ «Опис Виконаної роботи»
	3
	27.05.2025
	0.1
	Створено розділ «Висновки»
	4
	27.05.2025
	0.1
	Створено розділ «Додаток А»
	5
	27.05.2025
	0.1
	Створено розділ «Додаток Б»
	________________
2 ЗАВДАННЯ
Метою даної лабораторної роботи є розробка Bash-скрипта, що автоматизує процес перетворення розкладу занять, експортованого з інформаційної системи CIST Харківського національного університету радіоелектроніки, у формат, придатний для імпорту до Google Календаря. Очікуваний результат — текстовий CSV-файл, структура якого відповідає вимогам системи Google та містить детальну інформацію про навчальні заняття для вибраної академічної групи.
Завдання передбачає реалізацію скрипта з іменем smp-pzpi-23-5-zhylienkov-andrii-lab1, який може бути запущений у різних режимах, залежно від параметрів командного рядка. Серед ключових вимог до скрипта є:
1. підтримка інформаційних ключів --help та --version;
2. можливість тихої роботи без виведення проміжних повідомлень (-q, --quiet);
3. інтерактивний вибір академічної групи з-поміж тих, що містяться у вхідному файлі;
4. підтримка кириличного тексту в Windows-1251 з перетворенням в UTF-8;
5. правильне формування порядкових номерів занять окремо для кожного виду (Лб, Пз, Лк);
6. конвертація формату дати та часу до специфікації Google Calendar (mm/dd/yyyy, hh:mm AM/PM);
7. створення остаточного CSV-файла з ім’ям за шаблоном Google_TimeTable_??_??_20??.csv.
Окрім цього, результат виконання скрипта повинен бути збережений у відповідному файлі та (за відсутності тихого режиму) виведений у стандартний потік виведення. Сценарій враховуватиме обробку помилок, зокрема перевірку існування вхідного файла, наявності вибраної групи, коректності форматів тощо.
________________


3 ОПИС ВИКОНАНОЇ РОБОТИ
Програма є Bash-скриптом, який реалізує автоматизовану обробку розкладів занять для академічних груп, зокрема їх фільтрацію та конвертацію у формат, сумісний із Google Calendar. Скрипт починається з обробки аргументів командного рядка, перевіряючи, чи користувач викликав допомогу або бажає переглянути версію програми. У разі виклику з параметром --help відображається інструкція з використання, яка містить інформацію про можливі ключі командного рядка, включаючи тихий режим роботи (--quiet) та спосіб вказання назви групи й файлу розкладу. Якщо передано параметр --version, скрипт повідомляє про поточну версію програми.
Після цього ініціалізується логічна змінна quiet, яка визначає, чи слід виводити проміжні повідомлення. Якщо користувач вказав параметр -q або --quiet, повідомлення виводитись не будуть. Для цього використовується допоміжна функція log, яка здійснює перевірку значення змінної quiet та виводить повідомлення лише за умови її хибного значення.
На наступному етапі скрипт виконує пошук усіх файлів із розширенням .csv у поточному каталозі та виводить їх список користувачеві для вибору одного з них через інтерфейс select. Після вибору файлу даних здійснюється його перекодування з кодування Windows-1251 у UTF-8 за допомогою утиліти iconv, а також приведення форматування рядків до коректного вигляду шляхом заміни символів переводу рядка Windows (\r) на UNIX-формат (\n). Цей процес забезпечує уніфікацію кодування для подальшої коректної обробки CSV-файлу.
Далі скрипт виконує вилучення унікальних назв академічних груп із першого стовпця CSV-файлу, пропускаючи заголовок. Це реалізовано через awk-інструкцію, яка шукає шаблони, що відповідають різним можливим записам груп (включно з варіантами у дужках або розділеними комами), та формує відсортований список таких груп без повторень. Якщо жодна група не знайдена, скрипт завершує роботу із відповідним повідомленням. У разі наявності груп користувачеві пропонується вибрати одну з них, після чого скрипт зберігає її назву для подальшої обробки.
Вибрана група використовується для фільтрації рядків CSV-файлу з розкладом, де присутнє її позначення. Цей процес реалізується ще одним викликом awk, що враховує як повну назву групи, так і скорочену форму з позначенням лише номера. Відібрані записи записуються у тимчасовий CSV-файл, назва якого відповідає групі.
Щоб адаптувати ім’я вихідного файлу під формат Google Calendar, скрипт виконує вилучення дати з імені оригінального CSV-файлу за допомогою регулярного виразу. Якщо дата присутня у назві (у форматі dd_mm_yyyy), вона вставляється в ім’я фінального CSV-файлу для Google Calendar. Якщо ж формат імені не відповідає очікуваному шаблону, буде використано універсальне ім’я Google_TimeTable_output.csv.
Після цього здійснюється безпосереднє створення файлу у форматі, сумісному з Google Calendar. Спочатку додається заголовок файлу, який відповідає структурі, що підтримується сервісом (включаючи такі поля як назва предмету, дата і час початку та завершення, опис тощо). Усі наступні рядки обробляються з використанням awk. З кожного запису витягується назва предмету разом з його типом (лекція, лабораторна або практична), здійснюється підрахунок номеру пари для кожного типу заняття, та формуються відповідні поля для календаря. Окремо обробляються дати, які перетворюються у формат MM/DD/YYYY, та час, який конвертується у 12-годинний формат з позначенням AM/PM. У кінці формується запис із заповненням усіх полів згідно з вимогами Google Calendar.
Після завершення обробки скрипт повідомляє користувача про створення Google-сумісного файлу, а також виконує очищення — видаляє тимчасовий файл розкладу вибраної групи, що використовувався для обробки. Таким чином, забезпечується чистота робочого каталогу, зберігаючи лише необхідний результат. Уся логіка скрипту чітко структурована, забезпечує перевірку вхідних даних, сумісність форматів, підтримку різних варіантів запису груп, і зберігає фінальний файл у форматі, зручному для подальшого імпорту у сторонні сервіси календарів.
У повному обсязі програмний код, реалізований у межах цієї роботи, представлено в додатку Б.
________________


ВИСНОВКИ
У результаті виконання лабораторної роботи було створено Bash-скрипт, що реалізує повний цикл автоматизованої обробки розкладу занять для академічних груп із його подальшою конвертацією у формат, сумісний із Google Calendar. Скрипт підтримує інтерфейс командного рядка з аргументами, що дозволяють виводити допомогу, працювати в тихому режимі, обирати конкретну групу та обробляти розклад за будь-якою датою без потреби у зміні коду. Програма забезпечує коректне кодування вхідного файлу, здійснює фільтрацію даних за вказаною групою, перетворення формату дати й часу, а також автоматичне формування імені вихідного файлу. Окрім цього, було реалізовано очищення тимчасових файлів після завершення роботи, що покращує зручність та акуратність користування. Такий підхід демонструє навички роботи з інтерпретованими мовами, регулярними виразами, текстовою обробкою даних та побудовою інтерактивного інтерфейсу для користувача. Виконана робота підтвердила доцільність застосування сценаріїв оболонки для задач автоматизації обробки структурованих даних, зокрема для освітніх потреб.
________________


ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://youtu.be/UCvK5OZHWXI
Хронологічний опис відеозапису
00:17 — Вхідні параметри: допомога, версія, тихий режим
01:15 — Пошук та виведення .csv файлів і назв груп
04:10 — Сортування рядків розкладу для певної групи
05:50 — Редагування даних за вимогами Google Calendar
10:27 — Тестування програми
________________
ДОДАТОК Б
Програмний код
Б.1 smp-pzpi-23-5-zhylienkov-andrii-lab1-code
GitHub репозиторій: https://github.com/NureZhylienkovAndrii/smp-pzpi-23-5-zhylienkov-andrii/blob/main/Lab1/smp-pzpi-23-5-zhylienkov-andrii-lab1/smp-pzpi-23-5-zhylienkov-andrii-lab1-code.sh
    1 #!/bin/bash
  2
  3 if [[ "$1" == "--help" ]]; then
  4     echo "Usage: smp-pzpi-23-5-zhylienkov-andrii-lab1-code [--help | --version] | [[-q|--quiet] [ПЗПІ-23-5] TimeTable_11_04_2025]"
  5     echo "--help    Display this help message."
  6     echo "--version Show the version of the script."
  7     echo "-q, --quiet Suppress output."
  8     exit 0
  9 fi
 10
 11 if [[ "$1" == "--version" ]]; then
 12     echo "smp-pzpi-23-5-zhylienkov-andrii-lab1-code version 1.0"
 13     exit 0
 14 fi
 15
 16 quiet=false
 17 if [[ "$1" == "-q" || "$1" == "--quiet" ]]; then
 18     quiet=true
 19     shift
 20 fi
 21
 22 log() {
 23     if [[ $quiet != true ]]; then
 24         echo "$@"
 25     fi
 26 }
 27
 28 log "Available timetable files:"
 29 files=(*.csv)
 30 select file in "${files[@]}"; do
 31     if [[ -n "$file" ]]; then
 32         log "You selected: $file"
 33         break
 34     fi
 35 done
 36
 37 temp_file="$(mktemp)"
 38 iconv -f WINDOWS-1251 -t UTF-8 "$file" | sed 's/\r/\n/g' > "$temp_file" && mv "$temp_file" "$file"
 39
 40 mapfile -t groups < <(
 41     awk -F',' 'NR>1 {
 42         if (match($1, /ПЗПІ-23-[1-5]/, arr)) {
 43             print arr[0]
 44         } else if (match($1, /\(ПЗПІ-23-\)-[1-5]/, arr)) {
 45             gsub("[()]", "", arr[0])
 46             print arr[0]
 47         } else if (match($1, /ПЗПІ-23-[1-5],[1-5]/, arr)) {
 48             split(arr[0], groupArray, /,/)
 49             for (i in groupArray) print groupArray[i]
 50         }
 51     }' "$file" | sort -u
 52 )
 53
 54 if [[ ${#groups[@]} -eq 0 ]]; then
 55     log "No academic groups found in file!"
 56     exit 1
 57 fi
 58
 59 log "Available academic groups in $file:"
 60 select group in "${groups[@]}"; do
 61     if [[ -n "$group" ]]; then
 62         log "You selected: $group"
 63         break
 64     fi
 65 done
 66
 67 output_file="${group}.csv"
 68 group_num="${group: -1}"
 69
 70 awk -F',' -v group="$group" -v gnum="$group_num" 'NR==1 { print; next }
 71 {
 72     line = $0
 73     gsub("\"", "", line)
 74     if (line ~ "(^|[^0-9])" group "([^0-9]|$)" || line ~ "\\(ПЗПІ-23-\\)-" gnum)
 75         print $0
 76 }' "$file" > "$output_file"
 77
 78 date_part=$(basename "$file" | sed -n 's/^TimeTable_\([0-9]\{2\}_[0-9]\{2\}_[0-9]\{4\}\)\.csv$/\1/p')
 79
 80 if [[ -n "$date_part" ]]; then
 81     google_output="Google_TimeTable_${date_part}.csv"
 82 else
 83     google_output="Google_TimeTable_output.csv"
 84 fi
 85
 86 log "Subject,Start Date,Start Time,End Date,End Time,All Day Event,Description" > "$google_output"
 87
 88 awk -F',' '
 89 BEGIN {
 90     log_header = "Subject,Start Date,Start Time,End Date,End Time,All Day Event,Description";
 91     print log_header > "'"$google_output"'"
 92 }
 93
 94 NR > 1 {
 95     gsub("\"", "", $0)
 96     raw_subject = $1
 97     gsub(/^[0-9]+ /, "", raw_subject)
 98
 99     match(raw_subject, /([А-ЯІЇа-яіїA-Za-z0-9\-\s]+)\s+(Лб|Пз|Лк)/, m)
100     if (!m[1] || !m[2]) {
101         next
102     }
103
104     subject_name = m[1]
105     subject_type = m[2]
106     key = subject_name "-" subject_type
107
108     if (subject_type == "Лб") {
109         count[key]++
110         pair_index = int((count[key]+1)/2)
111     } else {
112         count[key]++
113         pair_index = count[key]
114     }
115
116     full_subject = raw_subject "; №" pair_index
117
118     split($2, sd, ".")
119     split($4, ed, ".")
120     start_date = sd[2] "/" sd[1] "/" sd[3]
121     end_date   = ed[2] "/" ed[1] "/" ed[3]
122
123     split($3, st, ":")
124     hour = st[1]; min = st[2]; sec = st[3]
125     if (hour >= 12) {
126         if (hour > 12) hour -= 12
127         ampm = "PM"
128     } else {
129         if (hour == 0) hour = 12
130         ampm = "AM"
131     }
132     start_time = sprintf("%02d:%02d:%02d %s", hour, min, sec, ampm)
133
134     split($5, et, ":")
135     hour = et[1]; min = et[2]; sec = et[3]
136     if (hour >= 12) {
137         if (hour > 12) hour -= 12
138         ampm = "PM"
139     } else {
140         if (hour == 0) hour = 12
141         ampm = "AM"
142     }
143     end_time = sprintf("%02d:%02d:%02d %s", hour, min, sec, ampm)
144
145     desc = $12
146
147     printf "\"%s\",%s,%s,%s,%s,False,\"%s\"\n", full_subject, start_date, start_time, end_date, end_time, desc >> "'"$google_output"'"
148 }
149 ' "$output_file"
150
151 log "Google Calendar CSV generated: '$google_output'"
152 rm -f "$output_file"